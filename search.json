[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Course Website"
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a two seven segment displays from 0 to F using a single seven segment module given a two 4 bit binary inputs. Five external green LEDs were programmed to display to the sum of the two digits displayed."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a two seven segment displays from 0 to F using a single seven segment module given a two 4 bit binary inputs. Five external green LEDs were programmed to display to the sum of the two digits displayed."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDesign Overview\nThe first step in the design was to determine the overall structure needed and the number of modules needed. The main function of this design was the flicker module which controlled the the oscillating signals that would control one segment at a time. The on-board high-speed oscillator was used to generate a 12 MHz clk signal that was fed into the flicker module. A 24 bit counter was used and on the 16th bit the counter would reset. The module would also need to output the 4 bit s value that corresponding to the current display being turned on. This s value that was to be displayed is fed into the seven segment module that outputs the correspdning segment values needed to display that digit. Lastly, a simple adder module was implemented to output the 5 bit sum or the two 4 bit inputs.\n\n\nTesting Procedure\nThe design was tested using automatic testbenches in Questa. Testbenches were written for each module: top, adder, flicker and the 7 segment display module. For the seven segment display testvectors were used same as in lab 1. The rest of the modules used assert statement within the testbench. The adder and flicker loop through all 256 cases for the two 4 bit input. The adder module asserted that the addition was correct. The flicker module checked that the cur_s output matched the corresponding anode0/anode1 signal. The top module asserted that the current signal high (anode0/anode1) matched the outputed segment values. For the top moduel expected values were generated for the led expected values and the segment expected values. The waveforms were generated and compared to confirm the behavior of the modules. These simulations confirmed the hardware behavior expected from the board."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nSource Code\nGithub Lab 2\n\n\nBlock diagram\n\n\n\nBlock diagram of Verilog Design\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top module utilizes the HSOSC built in module for the clk. The submodule seven_seg handles the seven segment display outputs. The submodule adder handles the addition of s0 and s1 for the led output and the submodule flicker handles the alternating flickering signals and outputting the correct s value to be displayed at a given time.\n\n\nSchematics\n Figure 2 shows the physical layout of the design with the 8 input switches on the left and on the right the two seven segment displays sharing the same output pins alone with 5 external green LEDs. For the green LEDs a 1k ohm resistor was used to limit current draw. The seven segment displays used a 240 ohm resistor. The transistor was used to drive a large amount of current for the anode pins of the display and a 390 ohm resistor was used to limit current draw from the FPGA pin.\n\nCalculation for current draw\n\n\n\nCurrent draw calculation\n\n\nFigure 3 shows the current draw calculation for the seven segment LED display, green LEDs, and transistor circuit. For the seven segment display, using the forward voltage from the data sheet and a 240 ohm resistor we can solve for the current through the LED which comes out to 5.4 mA. This current is pretty standard for an LED and is well under the absolute maximum forward current of 20 mA (from the datasheet).For the green LEDs the same calculation was used this time with a 1k ohm resistor to limit current down to 1 mA which is a very safe current for standard LEDs. For the transistor, we can take the difference of voltage from the 3.3V source and the 0.7V drop from the source to the gate and divide by R_t. The maximum output current from the FPGA pin is 8 mA per the datasheet. Solving the inequality results in the resisotr value must be greater than 325 ohms."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n Top module testbench shows a more zoomed out version of all the signals.\n Shows a zoomed version a couple of specific test cases to better see the outputs.\n Seven segment tesbench that is the same as lab 1. I reran the testbench to show it worked within this module but code remained the same.\n This is zoomed in so that you can see the actual values being outputed but all 256 cases were tested.\n This is the flicker module test bench that shows that the cur_s value matches the right input s0 or s1 based on which anode0/anode1 signal is high.\nThe design met all the objectives. Shown are the QuestaSim simulations all the submodules and the top module. The outputs and the expected outputs can be compared showing that all 256 inputs matched the expected outputs."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was successful with the two seven segment displays showing the correct hex number without visible flickering or bleeding of the digits. Only one seven segment module was used. The green LEDs display the the sum of the two 4 bit binary inputs. I spent ~20 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nCode produced by chatGPT from the first prompt.\n// -----------------------------------------------------------------------------\n// seven_seg_decoder_ca\n//   4-bit hex to 7-seg decoder for a *common-anode* display.\n//   Segment order is {a,b,c,d,e,f,g}; active-low outputs (0 lights a segment).\n// -----------------------------------------------------------------------------\nmodule seven_seg_decoder_ca (\n    input  logic [3:0] nibble,\n    output logic [6:0] seg   // {a,b,c,d,e,f,g}, 0 = on\n);\n    always_comb begin\n        unique case (nibble)\n            4'h0: seg = 7'b0000001; // 0\n            4'h1: seg = 7'b1001111; // 1\n            4'h2: seg = 7'b0010010; // 2\n            4'h3: seg = 7'b0000110; // 3\n            4'h4: seg = 7'b1001100; // 4\n            4'h5: seg = 7'b0100100; // 5\n            4'h6: seg = 7'b0100000; // 6\n            4'h7: seg = 7'b0001111; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0000100; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b1100000; // b\n            4'hC: seg = 7'b0110001; // C\n            4'hD: seg = 7'b1000010; // d\n            4'hE: seg = 7'b0110000; // E\n            4'hF: seg = 7'b0111000; // F\n            default: seg = 7'b1111111; // all off\n        endcase\n    end\nendmodule\n\n// -----------------------------------------------------------------------------\n// two_digit_time_mux\n//   Time-multiplex one decoder instance across two 4-bit inputs.\n//   The single decoder's output is latched alternately into seg0 and seg1.\n//   Parameterizable scan rate via a simple clock divider.\n// -----------------------------------------------------------------------------\nmodule two_digit_time_mux #(\n    // Divide ratio for the scan tick. With a 50 MHz clock, DIV_POW2=15 -&gt; ~1.5 kHz toggle\n    // (per digit ~750 Hz refresh), which is flicker-free. Adjust for your clock.\n    parameter int unsigned DIV_POW2 = 15\n) (\n    input  logic        clk,\n    input  logic        rst_n,      // active-low synchronous reset\n\n    input  logic [3:0]  in0,        // 4-bit value for \"digit 0\"\n    input  logic [3:0]  in1,        // 4-bit value for \"digit 1\"\n\n    output logic [6:0]  seg0,       // latched segments for digit 0 (active-low)\n    output logic [6:0]  seg1        // latched segments for digit 1 (active-low)\n);\n    // Clock divider to create a scan \"tick\"\n    logic [DIV_POW2-1:0] div_cnt;\n    logic                scan_tick;\n\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            div_cnt   &lt;= '0;\n            scan_tick &lt;= 1'b0;\n        end else begin\n            div_cnt   &lt;= div_cnt + 1'b1;\n            scan_tick &lt;= (&div_cnt); // tick when counter rolls over\n        end\n    end\n\n    // Which input are we currently decoding?\n    logic select_digit;  // 0 -&gt; in0/seg0, 1 -&gt; in1/seg1\n    always_ff @(posedge clk) begin\n        if (!rst_n) select_digit &lt;= 1'b0;\n        else if (scan_tick) select_digit &lt;= ~select_digit;\n    end\n\n    // Mux the current 4-bit input into the single decoder\n    logic [3:0] current_nibble;\n    always_comb begin\n        current_nibble = (select_digit == 1'b0) ? in0 : in1;\n    end\n\n    // Single shared decoder\n    logic [6:0] decoded_seg;\n    seven_seg_decoder_ca u_dec (\n        .nibble (current_nibble),\n        .seg    (decoded_seg)\n    );\n\n    // Latch the decoder output into the correct digit on each scan tick\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            seg0 &lt;= 7'b1111111; // all off (common-anode)\n            seg1 &lt;= 7'b1111111;\n        end else if (scan_tick) begin\n            if (select_digit == 1'b0) seg0 &lt;= decoded_seg;\n            else                      seg1 &lt;= decoded_seg;\n        end\n    end\n\nendmodule\nI gave the prompt to chatGPT and then I ran the code in raiant and the code synthesized just fine the first time. The methods used my chatGPT are kind of confusing to me and aren’t very readable. I took a lot at the netlist analyzer and I saw that its outputting seg0 and seg1 even though the top level module only outputs seg.\nNext, I gave chatGPT my lab 1 files, at first it didn’t actually open the files instead it just assumed what was int he file based on the second prompt so I had to ask it to actually open the files. Looking at that code produced it was a lot more similar to how I approached lab 2 because it was based off lab 1. One thing I noticed is that it used two different latches for the counter behavior and for the mux behevior and in my code those two behaviors are in the same always_ff block. This second run the quality of the output appeared to be a lot better because it was something I could more easily understand and didn’t use any unknown syntax/constructs. This code also synthesized fine the first time around, however, I feel like synthesizing isn’t exactly the best measure for the quality of code since it likely won’t do the intended behavior. I’m noticing that the LLMs don’t really like making new modules unless they are directed to so thats a design decision that it doesn’t execute very well. Giving the LLM files of my own code that were similar makes its a lot easier to understand the output code and trust that the module is having the intended behavior."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Emma Angel is a senior at Harvey Mudd College studying Engineering with a concentration in History. Her focus is in electrical engineering, with experience in PCB design, circuit analysis, and firmware development. She has also worked in manufacturing engineering, where she gained exposure to production processes and efforts to improve consistency and replicability.\nEmma is interested in learning more about microprocessors and embedded systems, and she enjoys developing her digital design skills through hands-on projects. She values opportunities to collaborate across disciplines to solve practical problems."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "First blog post\n\n\nWelcome to my Quarto portfolio for E155\n\n\n\n\n\nAug 28, 2025\n\n\nEmma Angel\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a seven segment display, from 0 to F given a binary input. LEDs were also programmed with set logic given the input, one LED was programmed to blink at 2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a seven segment display, from 0 to F given a binary input. LEDs were also programmed with set logic given the input, one LED was programmed to blink at 2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDesign Overview\nThe first step in the design was to determine the logic needed for the LEDs which resulted in an XOR, AND gates. The blinking LED used the on-board high-speed oscillator to generate a 48 MHz clock signal, then a counter was used at a cycle of 10000000 to generate a 2.4 Hz blinking frequency. The second part of the design included the 7 segment display module that mapped the binary input to the neccesary segments that need to be turned on to the display the digit.\n\n\nTesting Procedure\nThe design was tested using automatic testbenches in Questa. Testbenches were written for both the top module and the 7 segment display module. Testvectors with inputs and expected output values were given to compare the program outputs to the expected outputs. The waveforms were generated and compared to show that all 16 input values matches the segment display and led expectations. These simulations confirmed the physical behavior expected from the board."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nSource Code\nGithub Lab 1\n\n\nBlock diagram\n\n\n\nBlock diagram of Verilog Design\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top module includes the led controls utilizing the HSOSC built in module for the clk. The submodule seven_seg handles the seven segment display outputs.\n\n\nSchematics\n Figure 2 shows the physical layout of the design with the 4 input switches on the left and on the right the 7 segment LEDS along with the 3 external LEDs. For all LEDs a 1k ohm resistor was used to limit current draw. The input swithes were all configured with 100k ohm internal pullup resistors.\n\nCalculation for current draw\n\n\n\nCurrent draw calculation\n\n\nFigure 3 shows the current draw calculation for each seven segment LED display. Using the forward voltage from the data sheet and a standard 1k ohm resistor we can solve for the current through the LED which comes out to 1.3 mA. This current is pretty standard for an LED and is well under the absolute maximum forward current of 20 mA (from the datasheet)."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nTop module testbench\n\n\n\n\n\n7 segment testbench\n\n\nThe design met all the objectives. Shown are the QuestaSim simulations for both the top module and the seven segment module. The outputs and the expected outputs can be compared for both modules showing that all 16 inputs matched the expected outputs."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was succesful with the seven segment display showing the correct hex numbers. The LEDs demonstrated the correct logic and the correct blinking frequency of 2.4 Hz. From start to finish I spent ~25 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\n\nAI synthesized\n\n\nI gave the prompt to chatGPT and then I ran the code in raiant and the code synthesized just fine the first time. Above is screenshot showing the synthesized code.\nJust looking at how the ai solved the problem I can see that it seemed to define variables when maybe they weren’t really needed. However, the ouput seems right it does seem to produce the correct blinking. The LLM used localparam int which is a new variable type or at least one I haven’t seen used a lot. Althought the LLM synthesized I have a feeling there would be issues either simulating the code or testing it in hardware since that was still true for my own code. I think using AI at the end shows you that the logic and structure I used was correct and pretty standard however you need to work through it on your own in order to trust what the LLM is producing."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "First blog post",
    "section": "",
    "text": "For my initial reflection, I want to share my goals for this class. I’m taking Microprocessors because I’m interested in electrical engineering and want to strengthen my skills on the digital side of things. I’m also taking it because embedded systems are everywhere and can be applied across many different fields.\nMy main goal for the class is to develop a solid grasp of the concepts and learn as much as I can through the labs. I’m especially excited about working on my own custom project. I believe that with a project, you get out what you put in, and I’m looking forward to putting in the effort to deliver a fulfilling project that really shows what I’ve learned."
  }
]