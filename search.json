[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Course Website"
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 3 Report",
    "section": "",
    "text": "In this lab, a design was implemented to program the MCU to configure two timers, one used to control frequency and one used to control delay of a note. The timers were then used to play a song with accurate notes and timing."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 3 Report",
    "section": "",
    "text": "In this lab, a design was implemented to program the MCU to configure two timers, one used to control frequency and one used to control delay of a note. The timers were then used to play a song with accurate notes and timing."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 3 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDesign Overview\nThe first step in the design was to develop the struct for the TIM using timers 15 and 16. This was done in the header file. The next step was to determine what registers needed to be written to and in what order for timers 15 and 16 to be configured correctly. One was configured to run a delay_millis() function and another for pwm_update() which controlled the frequency changes of the notes. Lastly, in the main.c file configuration steps were taken for GPIO pin setup and PLL clock setup. Then a loop was used to play each note in the song array.\n\n\nTesting Procedure\nThe design was tested by using the segger step through function to make sure the registers were changing as expected. Then the MCU output was measured with an oscilliscope to ensure the correct ssqaure wave behavior with correct frequency was outputed. Lastly, plug it into the speaker and listen to the fruits of my labor."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 3 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nSource Code\nGithub Lab 3\n\n\nCalculations\n\n\n\n1% calculations for error in frequency\n\n\nThe table above shows the calculations for the ARR values and actual frequencies to then calculate the error. Below is a general walk through of the equations/steps used.\n\n\n\nWalkthrough of PSC and ARR calculations\n\n\nBelow are the minimum and maximum calculations for the frequency and durations. \n\n\nSchematics\n\n\n\nSchematic of physical circuit\n\n\nThe example schematic Figure 9-1 in the LM368 datasheet was built using the default gain of 20. A potienometer was used for volume control at the input of the op amp."
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 3 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion"
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 3 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was successful with fur elise playing at the right pitch and tempo. Then a custom song was also played. I spent 25 hours on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab 3 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe AI suggested that I used TIM2 which is not what I used. I used 15 and 16 because I needed two timers that were similar and could use the same struct. She calculated the PSC of 79 which is sort of in the middle of the PSCs I calculated. I used two different prescalers to match the needs of the range for each individual purpose. When it came to relevant registers I think she got the all. Maybe not all the specfic bits I had to write to but defintely got all the registers right. I didn’t even both giving the reference manual because of this. The example code is very similar to what I used except I had specific functions to update the code. She also got the part where you configure the GPIO as an alt function."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a two seven segment displays from 0 to F using a single seven segment module given a two 4 bit binary inputs. Five external green LEDs were programmed to display to the sum of the two digits displayed."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a two seven segment displays from 0 to F using a single seven segment module given a two 4 bit binary inputs. Five external green LEDs were programmed to display to the sum of the two digits displayed."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDesign Overview\nThe first step in the design was to determine the overall structure needed and the number of modules needed. The main function of this design was the flicker module which controlled the the oscillating signals that would control one segment at a time. The on-board high-speed oscillator was used to generate a 12 MHz clk signal that was fed into the flicker module. A 24 bit counter was used and on the 16th bit the counter would reset. The module would also need to output the 4 bit s value that corresponding to the current display being turned on. This s value that was to be displayed is fed into the seven segment module that outputs the correspdning segment values needed to display that digit. Lastly, a simple adder module was implemented to output the 5 bit sum or the two 4 bit inputs.\n\n\nTesting Procedure\nThe design was tested using automatic testbenches in Questa. Testbenches were written for each module: top, adder, flicker and the 7 segment display module. For the seven segment display testvectors were used same as in lab 1. The rest of the modules used assert statement within the testbench. The adder and flicker loop through all 256 cases for the two 4 bit input. The adder module asserted that the addition was correct. The flicker module checked that the cur_s output matched the corresponding anode0/anode1 signal. The top module asserted that the current signal high (anode0/anode1) matched the outputed segment values. For the top moduel expected values were generated for the led expected values and the segment expected values. The waveforms were generated and compared to confirm the behavior of the modules. These simulations confirmed the hardware behavior expected from the board."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nSource Code\nGithub Lab 2\n\n\nBlock diagram\n\n\n\nBlock diagram of Verilog Design\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top module utilizes the HSOSC built in module for the clk. The submodule seven_seg handles the seven segment display outputs. The submodule adder handles the addition of s0 and s1 for the led output and the submodule flicker handles the alternating flickering signals and outputting the correct s value to be displayed at a given time.\n\n\nSchematics\n Figure 2 shows the physical layout of the design with the 8 input switches on the left and on the right the two seven segment displays sharing the same output pins alone with 5 external green LEDs. For the green LEDs a 1k ohm resistor was used to limit current draw. The seven segment displays used a 240 ohm resistor. The transistor was used to drive a large amount of current for the anode pins of the display and a 390 ohm resistor was used to limit current draw from the FPGA pin.\n\nCalculation for current draw\n\n\n\nCurrent draw calculation\n\n\nFigure 3 shows the current draw calculation for the seven segment LED display, green LEDs, and transistor circuit. For the seven segment display, using the forward voltage from the data sheet and a 240 ohm resistor we can solve for the current through the LED which comes out to 5.4 mA. This current is pretty standard for an LED and is well under the absolute maximum forward current of 20 mA (from the datasheet).For the green LEDs the same calculation was used this time with a 1k ohm resistor to limit current down to 1 mA which is a very safe current for standard LEDs. For the transistor, we can take the difference of voltage from the 3.3V source and the 0.7V drop from the source to the gate and divide by R_t. The maximum output current from the FPGA pin is 8 mA per the datasheet. Solving the inequality results in the resisotr value must be greater than 325 ohms."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n Top module testbench shows a more zoomed out version of all the signals.\n Shows a zoomed version a couple of specific test cases to better see the outputs.\n Seven segment tesbench that is the same as lab 1. I reran the testbench to show it worked within this module but code remained the same.\n This is zoomed in so that you can see the actual values being outputed but all 256 cases were tested.\n This is the flicker module test bench that shows that the cur_s value matches the right input s0 or s1 based on which anode0/anode1 signal is high.\nThe design met all the objectives. Shown are the QuestaSim simulations all the submodules and the top module. The outputs and the expected outputs can be compared showing that all 256 inputs matched the expected outputs."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was successful with the two seven segment displays showing the correct hex number without visible flickering or bleeding of the digits. Only one seven segment module was used. The green LEDs display the the sum of the two 4 bit binary inputs. I spent ~20 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nCode produced by chatGPT from the first prompt.\n// -----------------------------------------------------------------------------\n// seven_seg_decoder_ca\n//   4-bit hex to 7-seg decoder for a *common-anode* display.\n//   Segment order is {a,b,c,d,e,f,g}; active-low outputs (0 lights a segment).\n// -----------------------------------------------------------------------------\nmodule seven_seg_decoder_ca (\n    input  logic [3:0] nibble,\n    output logic [6:0] seg   // {a,b,c,d,e,f,g}, 0 = on\n);\n    always_comb begin\n        unique case (nibble)\n            4'h0: seg = 7'b0000001; // 0\n            4'h1: seg = 7'b1001111; // 1\n            4'h2: seg = 7'b0010010; // 2\n            4'h3: seg = 7'b0000110; // 3\n            4'h4: seg = 7'b1001100; // 4\n            4'h5: seg = 7'b0100100; // 5\n            4'h6: seg = 7'b0100000; // 6\n            4'h7: seg = 7'b0001111; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0000100; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b1100000; // b\n            4'hC: seg = 7'b0110001; // C\n            4'hD: seg = 7'b1000010; // d\n            4'hE: seg = 7'b0110000; // E\n            4'hF: seg = 7'b0111000; // F\n            default: seg = 7'b1111111; // all off\n        endcase\n    end\nendmodule\n\n// -----------------------------------------------------------------------------\n// two_digit_time_mux\n//   Time-multiplex one decoder instance across two 4-bit inputs.\n//   The single decoder's output is latched alternately into seg0 and seg1.\n//   Parameterizable scan rate via a simple clock divider.\n// -----------------------------------------------------------------------------\nmodule two_digit_time_mux #(\n    // Divide ratio for the scan tick. With a 50 MHz clock, DIV_POW2=15 -&gt; ~1.5 kHz toggle\n    // (per digit ~750 Hz refresh), which is flicker-free. Adjust for your clock.\n    parameter int unsigned DIV_POW2 = 15\n) (\n    input  logic        clk,\n    input  logic        rst_n,      // active-low synchronous reset\n\n    input  logic [3:0]  in0,        // 4-bit value for \"digit 0\"\n    input  logic [3:0]  in1,        // 4-bit value for \"digit 1\"\n\n    output logic [6:0]  seg0,       // latched segments for digit 0 (active-low)\n    output logic [6:0]  seg1        // latched segments for digit 1 (active-low)\n);\n    // Clock divider to create a scan \"tick\"\n    logic [DIV_POW2-1:0] div_cnt;\n    logic                scan_tick;\n\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            div_cnt   &lt;= '0;\n            scan_tick &lt;= 1'b0;\n        end else begin\n            div_cnt   &lt;= div_cnt + 1'b1;\n            scan_tick &lt;= (&div_cnt); // tick when counter rolls over\n        end\n    end\n\n    // Which input are we currently decoding?\n    logic select_digit;  // 0 -&gt; in0/seg0, 1 -&gt; in1/seg1\n    always_ff @(posedge clk) begin\n        if (!rst_n) select_digit &lt;= 1'b0;\n        else if (scan_tick) select_digit &lt;= ~select_digit;\n    end\n\n    // Mux the current 4-bit input into the single decoder\n    logic [3:0] current_nibble;\n    always_comb begin\n        current_nibble = (select_digit == 1'b0) ? in0 : in1;\n    end\n\n    // Single shared decoder\n    logic [6:0] decoded_seg;\n    seven_seg_decoder_ca u_dec (\n        .nibble (current_nibble),\n        .seg    (decoded_seg)\n    );\n\n    // Latch the decoder output into the correct digit on each scan tick\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            seg0 &lt;= 7'b1111111; // all off (common-anode)\n            seg1 &lt;= 7'b1111111;\n        end else if (scan_tick) begin\n            if (select_digit == 1'b0) seg0 &lt;= decoded_seg;\n            else                      seg1 &lt;= decoded_seg;\n        end\n    end\n\nendmodule\nI gave the prompt to chatGPT and then I ran the code in raiant and the code synthesized just fine the first time. The methods used my chatGPT are kind of confusing to me and aren’t very readable. I took a lot at the netlist analyzer and I saw that its outputting seg0 and seg1 even though the top level module only outputs seg.\nNext, I gave chatGPT my lab 1 files, at first it didn’t actually open the files instead it just assumed what was int he file based on the second prompt so I had to ask it to actually open the files. Looking at that code produced it was a lot more similar to how I approached lab 2 because it was based off lab 1. One thing I noticed is that it used two different latches for the counter behavior and for the mux behevior and in my code those two behaviors are in the same always_ff block. This second run the quality of the output appeared to be a lot better because it was something I could more easily understand and didn’t use any unknown syntax/constructs. This code also synthesized fine the first time around, however, I feel like synthesizing isn’t exactly the best measure for the quality of code since it likely won’t do the intended behavior. I’m noticing that the LLMs don’t really like making new modules unless they are directed to so thats a design decision that it doesn’t execute very well. Giving the LLM files of my own code that were similar makes its a lot easier to understand the output code and trust that the module is having the intended behavior."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Emma Angel is a senior at Harvey Mudd College studying Engineering with a concentration in History. Her focus is in electrical engineering, with experience in PCB design, circuit analysis, and firmware development. She has also worked in manufacturing engineering, where she gained exposure to production processes and efforts to improve consistency and replicability.\nEmma is interested in learning more about microprocessors and embedded systems, and she enjoys developing her digital design skills through hands-on projects. She values opportunities to collaborate across disciplines to solve practical problems."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "First blog post\n\n\nWelcome to my Quarto portfolio for E155\n\n\n\n\n\nAug 28, 2025\n\n\nEmma Angel\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a seven segment display, from 0 to F given a binary input. LEDs were also programmed with set logic given the input, one LED was programmed to blink at 2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a seven segment display, from 0 to F given a binary input. LEDs were also programmed with set logic given the input, one LED was programmed to blink at 2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDesign Overview\nThe first step in the design was to determine the logic needed for the LEDs which resulted in an XOR, AND gates. The blinking LED used the on-board high-speed oscillator to generate a 48 MHz clock signal, then a counter was used at a cycle of 10000000 to generate a 2.4 Hz blinking frequency. The second part of the design included the 7 segment display module that mapped the binary input to the neccesary segments that need to be turned on to the display the digit.\n\n\nTesting Procedure\nThe design was tested using automatic testbenches in Questa. Testbenches were written for both the top module and the 7 segment display module. Testvectors with inputs and expected output values were given to compare the program outputs to the expected outputs. The waveforms were generated and compared to show that all 16 input values matches the segment display and led expectations. These simulations confirmed the physical behavior expected from the board."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nSource Code\nGithub Lab 1\n\n\nBlock diagram\n\n\n\nBlock diagram of Verilog Design\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top module includes the led controls utilizing the HSOSC built in module for the clk. The submodule seven_seg handles the seven segment display outputs.\n\n\nSchematics\n Figure 2 shows the physical layout of the design with the 4 input switches on the left and on the right the 7 segment LEDS along with the 3 external LEDs. For all LEDs a 1k ohm resistor was used to limit current draw. The input swithes were all configured with 100k ohm internal pullup resistors.\n\nCalculation for current draw\n\n\n\nCurrent draw calculation\n\n\nFigure 3 shows the current draw calculation for each seven segment LED display. Using the forward voltage from the data sheet and a standard 1k ohm resistor we can solve for the current through the LED which comes out to 1.3 mA. This current is pretty standard for an LED and is well under the absolute maximum forward current of 20 mA (from the datasheet)."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\nTop module testbench\n\n\n\n\n\n7 segment testbench\n\n\nThe design met all the objectives. Shown are the QuestaSim simulations for both the top module and the seven segment module. The outputs and the expected outputs can be compared for both modules showing that all 16 inputs matched the expected outputs."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was succesful with the seven segment display showing the correct hex numbers. The LEDs demonstrated the correct logic and the correct blinking frequency of 2.4 Hz. From start to finish I spent ~25 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\n\nAI synthesized\n\n\nI gave the prompt to chatGPT and then I ran the code in raiant and the code synthesized just fine the first time. Above is screenshot showing the synthesized code.\nJust looking at how the ai solved the problem I can see that it seemed to define variables when maybe they weren’t really needed. However, the ouput seems right it does seem to produce the correct blinking. The LLM used localparam int which is a new variable type or at least one I haven’t seen used a lot. Althought the LLM synthesized I have a feeling there would be issues either simulating the code or testing it in hardware since that was still true for my own code. I think using AI at the end shows you that the logic and structure I used was correct and pretty standard however you need to work through it on your own in order to trust what the LLM is producing."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a two seven segment displays from 0 to F using a single seven segment module given an input from a keypad. The most recent pressed button is shown on the right and the previous on the left."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3 Report",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to program a two seven segment displays from 0 to F using a single seven segment module given an input from a keypad. The most recent pressed button is shown on the right and the previous on the left."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDesign Overview\nThe first step in the design was to determine the fsm behavior that was needed to implement the scanner. A very basic scanner fsm was implemented. The output of that was then fed into another fsm that handled the debouncing of the keys. This was done by implenting a counter that counted until a certain target until the button is determined to be a valid press. This is then fed into a driver module that decodes the button pressed, updates the display, and then outputs the segment displays to the seven segment display and flickering module. The on-board high-speed oscillator was used to generate a 48MHz clock. This was then divided down to 183 Hz for the entire system to run on. This was done to control the scanning fsm which needed to be at a slower rate. The same clock was used for all modules for a synchronous design. ### Testing Procedure\nThe design was testing in both hardware and in simulation. Simulated showed accurate behavior of each individual module."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nSource Code\nGithub Lab 3\n\n\nBlock diagram\n\n\n\nBlock diagram of Verilog Design\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top module utilizes the HSOSC built in module for the clk. The submodule scanner is the fsm that scans the keypad for key presses and the debouncer module is another fsm that debounces the key press. The seg driver module decodes the key pressed to get the actual value and then updates the display accordingly. The submodule seven_seg handles the seven segment display outputs. The submodule flicker handles the alternating flickering signals and outputting the correct s value to be displayed at a given time.\n\n\nSchematics\n Figure 2 shows the physical layout of the design. The columns of the keypad were driven by output pins and the rows were read. A pulldown resistor of 680 ohms was used as pull downs on the row columns to avoid invalid logic inputs. The circuit for the seven segment display remained the same as in lab 2. The seven segment displays used a 240 ohm resistor. The transistor was used to drive a large amount of current for the anode pins of the display and a 390 ohm resistor was used to limit current draw from the FPGA pin.\n\n\nFSM\n \nThese are the fsms implemented for the scanning of the keypad and the debouncing of the keys. ## Results and Discussion\n\n\nTestbench Simulation\nSimulations were done but not shown here."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was semi successful with the two seven segment diplays displaying the button pressed and also updating accordingly. The design does not respond to other key presses while a key is stil being held. I spent maybe 60-70 hours on this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab 3 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nCode produced by chatGPT from the first prompt.\n//============================================================\n// Clock divider: generate slow enable ticks\n//============================================================\nmodule clock_divider #(\n    parameter int INPUT_HZ = 20_000_000,\n    parameter int SCAN_HZ  = 200,        // for keypad scan\n    parameter int MUX_HZ   = 1000        // for display multiplex\n)(\n    input  logic clk,\n    input  logic rst_n,\n    output logic tick_scan,              // ~200 Hz\n    output logic tick_mux                // ~1 kHz\n);\n\n    localparam int SCAN_DIV = INPUT_HZ / SCAN_HZ;\n    localparam int MUX_DIV  = INPUT_HZ / MUX_HZ;\n\n    int cnt_scan;\n    int cnt_mux;\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_scan &lt;= 0;\n            cnt_mux  &lt;= 0;\n            tick_scan &lt;= 0;\n            tick_mux  &lt;= 0;\n        end else begin\n            // scan tick\n            if (cnt_scan == SCAN_DIV-1) begin\n                cnt_scan  &lt;= 0;\n                tick_scan &lt;= 1;\n            end else begin\n                cnt_scan  &lt;= cnt_scan + 1;\n                tick_scan &lt;= 0;\n            end\n            // mux tick\n            if (cnt_mux == MUX_DIV-1) begin\n                cnt_mux  &lt;= 0;\n                tick_mux &lt;= 1;\n            end else begin\n                cnt_mux  &lt;= cnt_mux + 1;\n                tick_mux &lt;= 0;\n            end\n        end\n    end\nendmodule\n\n//============================================================\n// Keypad scanner: active-low 4x4 matrix\n//============================================================\nmodule keypad_scanner(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic tick_scan,         // slow scan enable\n    output logic [3:0] col_n,       // active-low columns\n    input  logic [3:0] row_n,       // active-low rows\n    output logic [3:0] key_code,    // hex 0–F\n    output logic       key_valid    // pulse when new key registered\n);\n    typedef enum logic [1:0] {IDLE, PRESSED} state_t;\n    state_t state, nxt_state;\n\n    logic [1:0] col_idx;\n    logic [3:0] active_row;\n    logic [3:0] latched_key;\n    logic       key_reg;\n\n    // Column drive: one low at a time\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) col_idx &lt;= 0;\n        else if (tick_scan) col_idx &lt;= col_idx + 1;\n    end\n    assign col_n = ~(4'b0001 &lt;&lt; col_idx); // active-low one column\n\n    // Decode key when row is active\n    always_comb begin\n        active_row = ~row_n; // convert to active-high\n        latched_key = 4'hX;\n        case (col_idx)\n            2'd0: latched_key = {2'b00, active_row[1:0]}; // rows 0–3 → codes 0–3\n            2'd1: latched_key = {2'b00, active_row[1:0]} + 4'd4;\n            2'd2: latched_key = {2'b00, active_row[1:0]} + 4'd8;\n            2'd3: latched_key = {2'b00, active_row[1:0]} + 4'd12;\n        endcase\n    end\n\n    // FSM to register single key per press-release\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) state &lt;= IDLE;\n        else        state &lt;= nxt_state;\n    end\n\n    always_comb begin\n        nxt_state = state;\n        key_reg   = 0;\n        case (state)\n            IDLE: if (|active_row) begin\n                      nxt_state = PRESSED;\n                      key_reg   = 1; // latch once\n                  end\n            PRESSED: if (~|active_row) nxt_state = IDLE; // wait for release\n        endcase\n    end\n\n    // Outputs\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            key_code  &lt;= 4'h0;\n            key_valid &lt;= 0;\n        end else begin\n            key_valid &lt;= key_reg;\n            if (key_reg) key_code &lt;= latched_key;\n        end\n    end\nendmodule\n\n//============================================================\n// Seven segment hex decoder (active-low segments)\n//============================================================\nmodule sevenseg_decoder(\n    input  logic [3:0] val,\n    output logic [6:0] seg_n  // {a,b,c,d,e,f,g}, active-low\n);\n    always_comb begin\n        case (val)\n            4'h0: seg_n = 7'b1000000;\n            4'h1: seg_n = 7'b1111001;\n            4'h2: seg_n = 7'b0100100;\n            4'h3: seg_n = 7'b0110000;\n            4'h4: seg_n = 7'b0011001;\n            4'h5: seg_n = 7'b0010010;\n            4'h6: seg_n = 7'b0000010;\n            4'h7: seg_n = 7'b1111000;\n            4'h8: seg_n = 7'b0000000;\n            4'h9: seg_n = 7'b0010000;\n            4'hA: seg_n = 7'b0001000;\n            4'hB: seg_n = 7'b0000011;\n            4'hC: seg_n = 7'b1000110;\n            4'hD: seg_n = 7'b0100001;\n            4'hE: seg_n = 7'b0000110;\n            4'hF: seg_n = 7'b0001110;\n            default: seg_n = 7'b1111111;\n        endcase\n    end\nendmodule\n\n//============================================================\n// Top level\n//============================================================\nmodule top_keypad_display(\n    input  logic clk,          // ~20 MHz internal osc\n    input  logic rst_n,\n    input  logic [3:0] row_n,  // keypad rows (active-low)\n    output logic [3:0] col_n,  // keypad cols (active-low)\n    output logic [6:0] seg_n,  // segments (active-low)\n    output logic [1:0] dig_n   // digit enables (active-low)\n);\n    logic tick_scan, tick_mux;\n    clock_divider div(\n        .clk(clk), .rst_n(rst_n),\n        .tick_scan(tick_scan),\n        .tick_mux(tick_mux)\n    );\n\n    logic [3:0] key_code;\n    logic       key_valid;\n    keypad_scanner scan(\n        .clk(clk), .rst_n(rst_n),\n        .tick_scan(tick_scan),\n        .col_n(col_n), .row_n(row_n),\n        .key_code(key_code), .key_valid(key_valid)\n    );\n\n    // Shift register for last two keys\n    logic [3:0] digit_lo, digit_hi;\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            digit_lo &lt;= 4'h0;\n            digit_hi &lt;= 4'h0;\n        end else if (key_valid) begin\n            digit_hi &lt;= digit_lo;\n            digit_lo &lt;= key_code;\n        end\n    end\n\n    // Display multiplex\n    logic mux_sel;\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) mux_sel &lt;= 0;\n        else if (tick_mux) mux_sel &lt;= ~mux_sel;\n    end\n\n    logic [3:0] val;\n    always_comb begin\n        if (mux_sel) begin\n            val   = digit_hi;\n            dig_n = 2'b10; // left digit active\n        end else begin\n            val   = digit_lo;\n            dig_n = 2'b01; // right digit active\n        end\n    end\n\n    sevenseg_decoder dec(.val(val), .seg_n(seg_n));\nendmodule\n\n```system verilog \n//-----------------------------------------------------------------------------\n// Keypress Register with One-Shot Pulse and Debounce\n// For 4x4 matrix keypad systems\n// Target: Lattice iCE40 UP5K\n//-----------------------------------------------------------------------------\nmodule keypress_register #(\n    parameter KEY_WIDTH = 4   // 4 bits for hex keypad\n)(\n    input  logic              clk,\n    input  logic              reset_n,        // Active-low sync reset\n    input  logic              key_valid,      // High when a key is detected (debounced scan result)\n    input  logic [KEY_WIDTH-1:0] key_code,    // Current key code from scanner\n\n    output logic              new_key_pulse,  // One-cycle pulse on new keypress\n    output logic [KEY_WIDTH-1:0] reg_key      // Last registered key code\n);\n\n    // FSM state definitions\n    typedef enum logic [1:0] {\n        IDLE      = 2'b00, // No key pressed\n        PRESSED   = 2'b01, // Key press accepted, waiting for release\n        HOLD      = 2'b10  // Key still held, ignore until release\n    } state_t;\n\n    state_t state, next_state;\n\n    // Outputs and registers\n    logic [KEY_WIDTH-1:0] next_reg_key;\n    logic                  pulse_int;\n\n    // Sequential state & outputs\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            state         &lt;= IDLE;\n            reg_key       &lt;= '0;\n            new_key_pulse &lt;= 1'b0;\n        end else begin\n            state         &lt;= next_state;\n            reg_key       &lt;= next_reg_key;\n            new_key_pulse &lt;= pulse_int;\n        end\n    end\n\n    // FSM next state logic\n    always_comb begin\n        next_state   = state;\n        next_reg_key = reg_key;\n        pulse_int    = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (key_valid) begin\n                    // First detection of a new key\n                    next_state   = PRESSED;\n                    next_reg_key = key_code;\n                    pulse_int    = 1'b1; // Fire one-shot\n                end\n            end\n\n            PRESSED: begin\n                if (key_valid) begin\n                    // Stay here while key remains pressed\n                    next_state = HOLD;\n                end else begin\n                    // If glitch/release quickly, go back to IDLE\n                    next_state = IDLE;\n                end\n            end\n\n            HOLD: begin\n                if (!key_valid) begin\n                    // Key released → ready for next press\n                    next_state = IDLE;\n                end\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n\n\nI feel like the first prompt was pretty okay. It synthesized in radiant just fine. At a glance I see the main ideas in the code produced that should cover most cases."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "First blog post",
    "section": "",
    "text": "For my initial reflection, I want to share my goals for this class. I’m taking Microprocessors because I’m interested in electrical engineering and want to strengthen my skills on the digital side of things. I’m also taking it because embedded systems are everywhere and can be applied across many different fields.\nMy main goal for the class is to develop a solid grasp of the concepts and learn as much as I can through the labs. I’m especially excited about working on my own custom project. I believe that with a project, you get out what you put in, and I’m looking forward to putting in the effort to deliver a fulfilling project that really shows what I’ve learned."
  }
]